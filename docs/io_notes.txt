Okay how to handle the IO

We need a io thread.

I think the best pace to put it will be the filesystem
The fileststem can then managed and post completed jobs?

I think things like opening files should also be in jobs?


Things should be done with aligned reds also.
What todo about buffers and what not...


I want to read a game file.

I want to dispatch a open file request.
The IO thread will then try and open the file.

We don't find out if it opened till a frame later?

Lets forgoet about open / close for now.

-----------------------------------------------

When ever we want to read we dispatch a read into a que and wait for it to complete.
When the read thread gets the rests it creates a job to process the data.
So the io request will have info about the job it's going to post.

The problem hese is potentially having to many buffers alive when processing data.
One potentiall solution will be the filesystem maintains buffers for aligned reads 2-3 0x40000 buffers.
And performs the reading into them.

Meaning the reast of the system dispatches file, offset, size, and process job.
So 100's of IO requests can be qued each frame and the IO thread works through them.

But once the data has been read into one of the buffers it's going to need to be prosesed before it can be used again for io.
Which is not ideal as we ideally want to maximise IO through put, which means always reading.


Is allocating the memory for files we want to read so bad tho?
Since we are only going to be loading what we can store in memory anyway except textures..


Things we load from disk:
textures
materials
shaders(source)
config files
scripts
levels
models
animations
sounds

Textures will be packed in a streaming files.

All other assets can be loaded either from disk or a pak file.
Most of the files have thiere memory stay around post load also.

So maybe allocating memory for each is not bad.


How to keep reads aligned tho :()
I guess that only matters for the streamed files and packs.
As other files are read in entirity.

Some system needs to be worked out how to read the file headers tho and then request rest of data.
So specific file handlers need to be made, that get called once the header is read and dispatch a read quests for the rest of the data.
Things like failing to load a file needs to also be handled.

-----------------------------------------------

So it's not that bad.
Other than the fact requesting resources now needs to be async.

If you request a model to be loaded you don't wait for it to load.
It creates a IO task and the processing job is spawned once the IO is complete.
Then the model is then updated.


So it will be setup so that everything is a blank asset when returned.
Then once the IO request has compelted it will either end up as the real model or Defaul depending on if the io operation failed.

For level loading tho we would want to know when all the callbacks have completed.
So we don't show hte level untill all models / default models have been set.

This will be nice also, as it will pave the way for delay loading models / swapping them out.

-----------------------------------------------

How to support encryption / compression.

Encryption can just be a job that's done in the scheduler in place of the memory.

The problem with compression / decompression is extra buffers.
A back log of uncompression jobs would increare memory requirements.
Unless the memory was allocated in the job.

Scenario:

We want to read a image for steamed format.
The image is stored compressed.
We need to perform N aligned reads to get that data.

We create a destination buffer for the image to go.
We dispatch the reads.
Ideally each read job gets performed on a fixed aligned buffer.

Once the data has been read into the buffer, a job should inflate the data into the destination buffer.

That means the aligned read buffers can't be reused untill the decompression job has been completed.
But the latency for running the job after the read has been completed should not be that long.

So as long as (adding job + time till job is ran + time job runs) is less than the read time of another aligned block
we will keep through put high.

Thinking about it, if a job to process the data takes longer than the aligned read does it matter, since we can't process X amount of data at that rate, there is no benfit in reading it in faster..

-----------------------------------------------

Pak files / stream files.

When a pak file is loaded, it basically becomes a virtual directory, with higher or lower priority (depending on engine settings)
But what is going to do the loading work for that.

Scemario:

When we want to load a level, we will load the pack file.
But what will do the work of reading the pack files information to build the virtual directory.
And while the virtual directory is building we don't want to dispatch file open requests, untill pack meta it loaded.


I guess the filesystem will be aware of the pak structure and thuis handler the loading of it.
So a IO request will be created by the filsystem that then runs a job once read.
This job will process the virtual directory and then 'mount it' after this is done we can begin reading assets.


-----------------------------------------------

Open / close files.

Do we want to dispatch a open request then wait for the result?
And then dispatch the reads.

OR

Dispatch open + read requests and it just returns fail or ok.

1st one has added latency between file been opened and read requests been sent.
I think supporting both would work well.

That way system is flexible.
Stuff like where we want to read the whole file, should just be one request with fail / ok.


-----------------------------------------------

How to handle waiting for async events to complete.

The IO thread waits untill it gets requests to process. but if we get a async request we need to enter a alertable state or poll if request is done.
Yet still processing open/close + additional asyn requests in the mean time.

If we could enter a alertable state yet still wake up for new requests that would be good.

If we go down the poll route. the thread would not sleep as long as there are outstanding asyn operations.
But how often would we poll :()


-----------------------------------------------

When we have a result for a IO request, should we call the callback in the IO thread?
Or que it and have it processed by main thread?

Calling GetOverlappedResult is very cheap.
When the operation has not completed it's a xor + cmp. only when the operation state is not STATUS_PENDING is a atomic operation involved.
