#ifndef _MDrawContext
#define _MDrawContext
//-
// ==========================================================================
// Copyright (C) 2010 Autodesk, Inc., and/or its licensors.  All
// rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its
// licensors,  which is protected by U.S. and Canadian federal copyright law
// and by international treaties.
//
// The Data may not be disclosed or distributed to third parties or be
// copied or duplicated, in whole or in part, without the prior written
// consent of Autodesk.
//
// The copyright notices in the Software and this entire statement,
// including the above license grant, this restriction and the following
// disclaimer, must be included in all copies of the Software, in whole
// or in part, and all derivative works of the Software, unless such copies
// or derivative works are solely in the form of machine-executable object
// code generated by a source language processor.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND.
// AUTODESK DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED
// WARRANTIES INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF
// NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE,
// OR ARISING FROM A COURSE OF DEALING, USAGE, OR TRADE PRACTICE. IN NO
// EVENT WILL AUTODESK AND/OR ITS LICENSORS BE LIABLE FOR ANY LOST
// REVENUES, DATA, OR PROFITS, OR SPECIAL, DIRECT, INDIRECT, OR
// CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS LICENSORS HAS
// BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.
// ==========================================================================
//+
//
// CLASS:    MDrawContext
//
// ****************************************************************************
//
// CLASS DESCRIPTION (MDrawContext)
//
//  MDrawContext allows access to hardware draw context information
//
// ****************************************************************************

#if defined __cplusplus

// ****************************************************************************
// INCLUDED HEADER FILES

#include <maya/MStatus.h>
#include <maya/MMatrix.h>
#include <maya/MDoubleArray.h>
#include <maya/MFloatPointArray.h>
#include <maya/MFloatVector.h>
#include <maya/MColor.h>
#include <maya/MBoundingBox.h>
#include <maya/MHWGeometry.h>
#include <maya/MFloatArray.h>
#include <maya/MUintArray.h>
#include <maya/MTextureManager.h>
#include <maya/MRenderTargetManager.h>

// ****************************************************************************
// NAMESPACE

namespace MHWRender
{

// ****************************************************************************
// DECLARATIONS

class MStateManager;
class MSamplerStateDesc;
class MLightParameterInformationSet;
struct MTextureAssignment;

// ****************************************************************************
// CLASS DECLARATION (MLightParameterInformation)
//! \ingroup OpenMayaRender
//! \brief A class for providing lighting information that may be used with Viewport 2.0
/*!
This class allows for access to various per-light information
accessible via the MDrawContext class in Viewport 2.0.
*/

class OPENMAYARENDER_EXPORT MLightParameterInformation
{
public:
	//! Specifies light parameter data types
	enum ParameterType {
		//! Invalid element type (default value)
		kInvalid,
		//! Boolean
		kBoolean,
		//! Signed 32-bit integer
		kInteger,
		//! IEEE single precision floating point
		kFloat,
		//! IEEE single precision floating point (x2)
		kFloat2,
		//! IEEE single precision floating point (x3)
		kFloat3,
		//! IEEE single precision floating point (x4)
		kFloat4,
		//! IEEE single precision floating point row-major matrix (4x4)
		kFloat4x4Row,
		//! IEEE single precision floating point column-major matrix (4x4)
		kFloat4x4Col,
		//! 2D texture
		kTexture2,
		//! Sampler
		kSampler
	};

	/*!	Specifies semantic meanings for predefined names for common or
		"stock" light parameters.
	
		The semantic is provided to aid in the determination of the appropriate 
		mapping of parameter values to programmable shader or fixed 
		function lighting inputs.
	
		Note that not all parameters exist on all lights so there may
		be no match for a given stock name. For example
		a directional light will have no position parameter.	
	*/
	enum StockParameterSemantic {
		//! No semantic 
		kNoSemantic,

		// Basic lighting parameters
		//! Light is enabled
		kLightEnabled ,
		//! World space position
		kWorldPosition,
		//! World space direction
		kWorldDirection,
		//! Intensity
		kIntensity,
		//! Color
		kColor,
		//! Emits diffuse lighting
		kEmitsDiffuse,
		//! Emits specular lighting
		kEmitsSpecular,
		//! Decay rate (0=No Decay, 1=Linear, 2=Quadratic, 3=Cubic)
		kDecayRate,
		//! Dropoff
		kDropoff,
		//! Cosine of the cone angle
		kCosConeAngle,

		// Basic shadowing parameters
		//! Incoming irradiance. Also marks the beginning of enums for shadowing
		kStartShadowParameters,
		kIrradianceIn = kStartShadowParameters,
		//! Shadow map
		kShadowMap,
		//! Shadow map sampler 
		kShadowSamp,
		//! Shadow map bias
		kShadowBias,
		//! Shadow map size
		kShadowMapSize,
		//! Shadow map view projection matrix
		kShadowViewProj,
		//! Shadow color
		kShadowColor,
		//! Global toggle for whether shadows are enabled or not
		kGlobalShadowOn,
		//! Local toggle per light for whether shadows are enabled or not
		kShadowOn
	};

	// String based access
	void parameterList(MStringArray& list) const;
	ParameterType parameterType(const MString& parameterName) const;
	StockParameterSemantic parameterSemantic(const MString& parameterName) const;
	unsigned int arrayParameterCount(const MString& parameterName) const;
	MStatus getParameter(const MString& parameterName, MIntArray & value );
	MStatus getParameter(const MString& parameterName, MFloatArray & value);
	MStatus getParameter(const MString& parameterName, MMatrix & value );
	MStatus getParameter(const MString& parameterName, MSamplerStateDesc & samplerDesc );
	void * getParameterTextureHandle(const MString& parameterName );
	MStatus getParameter(const MString& parameterName, MTextureAssignment &value );

	static const char* className();

protected:
	~MLightParameterInformation();
private:
	MLightParameterInformation(void* data, void* data2);
	void set( void* data, void *data2 );
	
	// Internal parameter helpers
	void buildParamNameMap();
	void* findParameterFromName( const MString &string, MStatus &status ) const;
	MStatus getParameter(void* vparam, MSamplerStateDesc & samplerDesc );

	void* fData;
	void* fData2;
	void* fParamNameMapper;

	friend class MDrawContext;
	friend class MLightParameterInformationSet;
};

// ****************************************************************************
// CLASS DECLARATION (MDrawContext)

//! \ingroup OpenMayaRender
//! \brief Class to allow access to hardware draw context information.
/*!
MDrawContext provides access to current hardware draw context information
when drawing is performed in either MPxShaderOverride or MPxDrawOverride.

MDrawContext is read-only and cannot be instantiated by the plugin writer.

The information provided includes various transformation matrices,
camera information, and render target information such as output buffer
size. It is also possible to access and alter GPU state through this calss.

There are a few main advantages for using this class:

1. The data is computed and cached as required. This can avoid work for the
plugin writer to extract this information themselves.
2. The plugin writer should not need to directly access the device to extract
this information. Any data extraction from the device has a performance
penalty which can be avoided.
3. The information is device aware, meaning that it will return the correct
results based on the current active device. 

Some information will vary from one draw to the next draw such as the
object-to-world matrix which will change as different objects are being drawn.
*/
class OPENMAYARENDER_EXPORT MDrawContext
{
public:
	//! Matrices that can be accessed
	enum MatrixType {
		kWorldMtx,                      //!< Object to world matrix
		kWorldTransposeMtx,             //!< Object to world matrix transpose
		kWorldInverseMtx,               //!< Object to world matrix inverse
		kWorldTranspInverseMtx,         //!< Object to world matrix transpose inverse (adjoint)
		kViewMtx,                       //!< World to view matrix
		kViewTransposeMtx,              //!< World to view matrix tranpose
		kViewInverseMtx,                //!< World to view matrix inverse
		kViewTranspInverseMtx,          //!< World to view matrix transpose inverse (adjoint)
		kProjectionMtx,                 //!< Projection matrix
		kProjectionTranposeMtx,         //!< Projection matrix tranpose
		kProjectionInverseMtx,          //!< Projection matrix inverse

		kProjectionTranspInverseMtx,    //!< Projection matrix tranpose inverse (adjoint)
		kViewProjMtx,                   //!< View * projection matrix
		kViewProjTranposeMtx,           //!< View * projection matrix tranpose
		kViewProjInverseMtx,            //!< View * projection matrix inverse
		kViewProjTranspInverseMtx,      //!< View * projection matrix tranpose inverse (adjoint)
		kWorldViewMtx,                  //!< World * view matrix
		kWorldViewTransposeMtx,         //!< World * view matrix transpose
		kWorldViewInverseMtx,           //!< World * view matrix inverse
		kWorldViewTranspInverseMtx,     //!< World * view matrix transpose inverse (adjoint)
		kWorldViewProjMtx,              //!< World * view * projection matrix
		
		kWorldViewProjTransposeMtx,     //!< World * view * projection matrix transpose
		kWorldViewProjInverseMtx,       //!< World * view * projection matrix inverse
		kWorldViewProjTranspInverseMtx  //!< World * view * projection matrix tranpose inverse (adjoint)
	};
	static MDrawContext::MatrixType semanticToMatrixType( const MString &value, MStatus* ReturnStatus=NULL );
	MMatrix getMatrix( MDrawContext::MatrixType mtype, MStatus* ReturnStatus=NULL ) const;

	//! Vectors or positions that can be accessed
	enum TupleType {
		kViewPosition,		//!< View position
		kViewDirection,		//!< View direction
		kViewUp,			//!< View up vector
		kViewRight,			//!< View right vector
		kViewportPixelSize,	//!< Viewport size in pixels
	};
	static MDrawContext::TupleType semanticToTupleType( const MString &value, MStatus* ReturnStatus=NULL );
	MDoubleArray getTuple( MDrawContext::TupleType ttype, MStatus* ReturnStatus=NULL ) const;

	MBoundingBox getSceneBox(MStatus* ReturnStatus=NULL) const;
	MBoundingBox getFrustumBox(MStatus* ReturnStatus) const;

	MStatus getViewportDimensions( int &originX, int &originY, int &width, int &height) const;
	MStatus getRenderTargetSize( int &width, int &height) const;
	MStatus getDepthRange( float &nearVal, float &farVal ) const;
	bool viewDirectionAlongNegZ( MStatus* ReturnStatus ) const;

	unsigned int numberOfActiveLights(MStatus* ReturnStatus=NULL) const;
	MStatus getLightInformation( unsigned int lightNumber,
								 MFloatPointArray &positions, MFloatVector &direction,
								 float &intensity, MColor &color, bool &hasDirection,
								 bool &hasPosition ) const;
	MLightParameterInformation* getLightParameterInformation( unsigned int lightNumber ) const;

	//! Display style
    enum DisplayStyle {
        kGouraudShaded = 0x1,		//!< Gouraud shaded display.
        kWireFrame = 0x2,			//!< Wire frame display.
    };
	int getDisplayStyle() const;

	MHWRender::MStateManager* getStateManager() const;

	static const char* className();

public:
	// Depreciated
	MStatus getLightInformation( unsigned int lightNumber,
								 MFloatPoint &position, MFloatVector &direction,
								 float &intensity, MColor &color, bool &hasDirection,
								 bool &hasPosition ) const;

private:
	MDrawContext();
	~MDrawContext();

	void setData(void* data);
	void* fData;
	MStateManager* fStateManager;

	void * fLightInformation;


};     /* draw context */

} // namespace MHWRender

#endif /* __cplusplus */
#endif /* _MDrawContext */
